# coding: utf-8

"""
    DIGI storage API V2

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 2.1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class MountsFilesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def files_change_version(self, mount_id, path, version, **kwargs):  # noqa: E501
        """Change file version  # noqa: E501

        Replace a file with an older version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_change_version(mount_id, path, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param str version: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_change_version_with_http_info(mount_id, path, version, **kwargs)  # noqa: E501
        else:
            (data) = self.files_change_version_with_http_info(mount_id, path, version, **kwargs)  # noqa: E501
            return data

    def files_change_version_with_http_info(self, mount_id, path, version, **kwargs):  # noqa: E501
        """Change file version  # noqa: E501

        Replace a file with an older version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_change_version_with_http_info(mount_id, path, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param str version: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_change_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_change_version`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_change_version`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `files_change_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/versions/change', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_get(self, mount_id, path, **kwargs):  # noqa: E501
        """Download a file  # noqa: E501

        Download a file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param bool force: Forces the web browsers to download the file. Adds the `Content-Disposition: attachment; filename=\"file.txt\"; filename*=UTF-8''file.txt` header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_get_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_get_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_content_files_get_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """Download a file  # noqa: E501

        Download a file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param bool force: Forces the web browsers to download the file. Adds the `Content-Disposition: attachment; filename=\"file.txt\"; filename*=UTF-8''file.txt` header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_content_files_get`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_content_files_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream', 'application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/mounts/{mountId}/files/get', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_get_multi(self, **kwargs):  # noqa: E501
        """Download multiple files in a ZIP archive  # noqa: E501

        Download multiple files in a ZIP archive.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_multi(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] files:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_get_multi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_get_multi_with_http_info(**kwargs)  # noqa: E501
            return data

    def files_content_files_get_multi_with_http_info(self, **kwargs):  # noqa: E501
        """Download multiple files in a ZIP archive  # noqa: E501

        Download multiple files in a ZIP archive.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_multi_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] files:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['files']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_get_multi" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'files' in params:
            form_params.append(('files', params['files']))  # noqa: E501
            collection_formats['files'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream', 'application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/files/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_get_multi_name(self, name, **kwargs):  # noqa: E501
        """Download multiple files in a ZIP archive  # noqa: E501

        Helper endpoint to include the name of the ZIP archive because web browsers use the last segment of the URL for the downloaded file name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_multi_name(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param list[str] files:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_get_multi_name_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_get_multi_name_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def files_content_files_get_multi_name_with_http_info(self, name, **kwargs):  # noqa: E501
        """Download multiple files in a ZIP archive  # noqa: E501

        Helper endpoint to include the name of the ZIP archive because web browsers use the last segment of the URL for the downloaded file name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_multi_name_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param list[str] files:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'files']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_get_multi_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `files_content_files_get_multi_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'files' in params:
            form_params.append(('files', params['files']))  # noqa: E501
            collection_formats['files'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream', 'application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/files/get/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_get_name(self, mount_id, path, name, **kwargs):  # noqa: E501
        """Download a file  # noqa: E501

        Helper endpoint to include the name of the file because web browsers use the last segment of the URL for the downloaded file name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_name(mount_id, path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param str name: (required)
        :param bool force: Forces the web browsers to download the file. Adds the `Content-Disposition: attachment; filename=\"file.txt\"; filename*=UTF-8''file.txt` header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_get_name_with_http_info(mount_id, path, name, **kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_get_name_with_http_info(mount_id, path, name, **kwargs)  # noqa: E501
            return data

    def files_content_files_get_name_with_http_info(self, mount_id, path, name, **kwargs):  # noqa: E501
        """Download a file  # noqa: E501

        Helper endpoint to include the name of the file because web browsers use the last segment of the URL for the downloaded file name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_name_with_http_info(mount_id, path, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param str name: (required)
        :param bool force: Forces the web browsers to download the file. Adds the `Content-Disposition: attachment; filename=\"file.txt\"; filename*=UTF-8''file.txt` header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path', 'name', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_get_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_content_files_get_name`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_content_files_get_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `files_content_files_get_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream', 'application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/mounts/{mountId}/files/get/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_get_name_post(self, path, mount_id, name, **kwargs):  # noqa: E501
        """Download a folder with filtered files  # noqa: E501

        Helper endpoint to include the name of the file because web browsers use the last segment of the URL for the downloaded file name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_name_post(path, mount_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param str name: (required)
        :param list[str] files:
        :param bool force: Forces the web browsers to download the file. Adds the `Content-Disposition: attachment; filename=\"file.txt\"; filename*=UTF-8''file.txt` header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_get_name_post_with_http_info(path, mount_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_get_name_post_with_http_info(path, mount_id, name, **kwargs)  # noqa: E501
            return data

    def files_content_files_get_name_post_with_http_info(self, path, mount_id, name, **kwargs):  # noqa: E501
        """Download a folder with filtered files  # noqa: E501

        Helper endpoint to include the name of the file because web browsers use the last segment of the URL for the downloaded file name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_name_post_with_http_info(path, mount_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param str name: (required)
        :param list[str] files:
        :param bool force: Forces the web browsers to download the file. Adds the `Content-Disposition: attachment; filename=\"file.txt\"; filename*=UTF-8''file.txt` header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'name', 'files', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_get_name_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_content_files_get_name_post`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_content_files_get_name_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `files_content_files_get_name_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'files' in params:
            form_params.append(('files', params['files']))  # noqa: E501
            collection_formats['files'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream', 'application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/mounts/{mountId}/files/get/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_get_post(self, path, mount_id, **kwargs):  # noqa: E501
        """Download a folder with filtered files  # noqa: E501

        Download a folder with filtered files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_post(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param list[str] files:
        :param bool force: Forces the web browsers to download the file. Adds the `Content-Disposition: attachment; filename=\"file.txt\"; filename*=UTF-8''file.txt` header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_get_post_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_get_post_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_content_files_get_post_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """Download a folder with filtered files  # noqa: E501

        Download a folder with filtered files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_get_post_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param list[str] files:
        :param bool force: Forces the web browsers to download the file. Adds the `Content-Disposition: attachment; filename=\"file.txt\"; filename*=UTF-8''file.txt` header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'files', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_get_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_content_files_get_post`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_content_files_get_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'files' in params:
            form_params.append(('files', params['files']))  # noqa: E501
            collection_formats['files'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream', 'application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/mounts/{mountId}/files/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_list_recursive(self, mount_id, path, **kwargs):  # noqa: E501
        """Get a recursive stream of files and folders  # noqa: E501

         Get a recursive stream of files and folders.  ## Example response  ```json > GET /content/api/v2.1/mounts/f13b5804-563d-4aed-b831-ca0246a1cad1/files/listrecursive?path=/path/to/dir HTTP/1.1 > < HTTP/1.1 200 OK < Content-Type: application/x-ndjson; charset=utf-8 < Transfer-Encoding: chunked < {\"type\":\"file\",\"path\":\"/\",\"file\":{\"name\":\"1\",\"type\":\"dir\",\"modified\":1487861241075,\"size\":0,\"contentType\":\"\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/01ab.jpg\",\"file\":{\"name\":\"01ab.jpg\",\"type\":\"file\",\"modified\":1494936799097,\"size\":36494,\"contentType\":\"image/jpeg\",\"hash\":\"2eedb741f199ecc19f1ba815d3d9914d\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/10 (1).txt\",\"file\":{\"name\":\"10 (1).txt\",\"type\":\"file\",\"modified\":1559913936402,\"size\":3,\"contentType\":\"text/plain\",\"hash\":\"31d30eea8d0968d6458e0ad0027c9f80\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/2\",\"file\":{\"name\":\"2\",\"type\":\"dir\",\"modified\":1487861247967,\"size\":0,\"contentType\":\"\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/2/3\",\"file\":{\"name\":\"3\",\"type\":\"dir\",\"modified\":1487861253650,\"size\":0,\"contentType\":\"\",\"tags\":{}}} ```  ## Example response for an offline device  ```json > GET /content/api/v2.1/mounts/f13b5804-563d-4aed-b831-ca0246a1cad1/files/listrecursive?path=/path/to/dir HTTP/1.1 > < HTTP/1.1 404 Not Found < Content-Length: 115 < Content-Type: application/json; charset=utf-8 < {\"error\":{\"code\":\"DeviceOffline\",\"message\":\"Device is offline\"},\"requestId\":\"7d17fa00-eea6-40d6-4ea8-4ef1496530ae\"} ```  ## External devices  For external cloud devices list recursive only works if the device is synchronized. If the device is not synchronized the error code will be `FilesNotSynced`.  ## Errors  If an error occurs when list items have already been sent the response will end with an error item:  ```json > GET /content/api/v2.1/mounts/f13b5804-563d-4aed-b831-ca0246a1cad1/files/listrecursive?path=/path/to/dir HTTP/1.1 > < HTTP/1.1 200 OK < Content-Type: application/x-ndjson; charset=utf-8 < Transfer-Encoding: chunked < {\"type\":\"file\",\"path\":\"/\",\"file\":{\"name\":\"\",\"type\":\"dir\",\"modified\":1578316978020,\"size\":0,\"contentType\":\"\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/.bin\",\"file\":{\"name\":\".bin\",\"type\":\"dir\",\"modified\":1578316950052,\"size\":0,\"contentType\":\"\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/.bin/JSONStream\",\"file\":{\"name\":\"JSONStream\",\"type\":\"file\",\"modified\":1578316950024,\"size\":20,\"contentType\":\"application/octet-stream\",\"tags\":{}}} {\"type\":\"error\",\"error\":{\"code\":\"DeviceOffline\",\"message\":\"Device is offline\"}} ```  ## Paths  All paths in items are relative to the specified path. The first item is always an file info for the specified path which means that the first item will always have path `/`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_list_recursive(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesListRecursiveItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_list_recursive_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_list_recursive_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_content_files_list_recursive_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """Get a recursive stream of files and folders  # noqa: E501

         Get a recursive stream of files and folders.  ## Example response  ```json > GET /content/api/v2.1/mounts/f13b5804-563d-4aed-b831-ca0246a1cad1/files/listrecursive?path=/path/to/dir HTTP/1.1 > < HTTP/1.1 200 OK < Content-Type: application/x-ndjson; charset=utf-8 < Transfer-Encoding: chunked < {\"type\":\"file\",\"path\":\"/\",\"file\":{\"name\":\"1\",\"type\":\"dir\",\"modified\":1487861241075,\"size\":0,\"contentType\":\"\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/01ab.jpg\",\"file\":{\"name\":\"01ab.jpg\",\"type\":\"file\",\"modified\":1494936799097,\"size\":36494,\"contentType\":\"image/jpeg\",\"hash\":\"2eedb741f199ecc19f1ba815d3d9914d\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/10 (1).txt\",\"file\":{\"name\":\"10 (1).txt\",\"type\":\"file\",\"modified\":1559913936402,\"size\":3,\"contentType\":\"text/plain\",\"hash\":\"31d30eea8d0968d6458e0ad0027c9f80\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/2\",\"file\":{\"name\":\"2\",\"type\":\"dir\",\"modified\":1487861247967,\"size\":0,\"contentType\":\"\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/2/3\",\"file\":{\"name\":\"3\",\"type\":\"dir\",\"modified\":1487861253650,\"size\":0,\"contentType\":\"\",\"tags\":{}}} ```  ## Example response for an offline device  ```json > GET /content/api/v2.1/mounts/f13b5804-563d-4aed-b831-ca0246a1cad1/files/listrecursive?path=/path/to/dir HTTP/1.1 > < HTTP/1.1 404 Not Found < Content-Length: 115 < Content-Type: application/json; charset=utf-8 < {\"error\":{\"code\":\"DeviceOffline\",\"message\":\"Device is offline\"},\"requestId\":\"7d17fa00-eea6-40d6-4ea8-4ef1496530ae\"} ```  ## External devices  For external cloud devices list recursive only works if the device is synchronized. If the device is not synchronized the error code will be `FilesNotSynced`.  ## Errors  If an error occurs when list items have already been sent the response will end with an error item:  ```json > GET /content/api/v2.1/mounts/f13b5804-563d-4aed-b831-ca0246a1cad1/files/listrecursive?path=/path/to/dir HTTP/1.1 > < HTTP/1.1 200 OK < Content-Type: application/x-ndjson; charset=utf-8 < Transfer-Encoding: chunked < {\"type\":\"file\",\"path\":\"/\",\"file\":{\"name\":\"\",\"type\":\"dir\",\"modified\":1578316978020,\"size\":0,\"contentType\":\"\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/.bin\",\"file\":{\"name\":\".bin\",\"type\":\"dir\",\"modified\":1578316950052,\"size\":0,\"contentType\":\"\",\"tags\":{}}} {\"type\":\"file\",\"path\":\"/.bin/JSONStream\",\"file\":{\"name\":\"JSONStream\",\"type\":\"file\",\"modified\":1578316950024,\"size\":20,\"contentType\":\"application/octet-stream\",\"tags\":{}}} {\"type\":\"error\",\"error\":{\"code\":\"DeviceOffline\",\"message\":\"Device is offline\"}} ```  ## Paths  All paths in items are relative to the specified path. The first item is always an file info for the specified path which means that the first item will always have path `/`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_list_recursive_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesListRecursiveItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_list_recursive" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_content_files_list_recursive`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_content_files_list_recursive`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/x-ndjson; charset=utf-8', 'application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/mounts/{mountId}/files/listrecursive', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesListRecursiveItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_put(self, path, mount_id, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        File can be uploaded either using a multi-part form or directly. You can use Chunked transfer encoding if the size of the file is not known in advance (streaming upload).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_put(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param Object body: File
        :param str filename: Name of the uploaded file. If this parameter is not set and multipart body is used, the file name from the multipart body will be used (this parameter takes precedence). If raw request body is used this parameter is required.
        :param bool info: Return full file info (`FilesFile`) in the response.
        :param bool overwrite: Overwrite an existing file.
        :param float overwrite_if_modified: Overwrite an existing file if modified matches.
        :param float overwrite_if_size: Overwrite an existing file if size matches.
        :param str overwrite_if_hash: Overwrite an existing file if hash matches.
        :param bool overwrite_ignore_nonexistent: Overwrite an existing file if other parameters match (e.g. overWriteIfModified) but create a new file if the old one does not exist.
        :param bool autorename: Overwrite an existing file.
        :param float modified: Set custom value for modified. Current time by default.
        :param list[str] tags: Tags for the new file. Format: key=value
        :return: FilesFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_put_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_put_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_content_files_put_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        File can be uploaded either using a multi-part form or directly. You can use Chunked transfer encoding if the size of the file is not known in advance (streaming upload).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_put_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param Object body: File
        :param str filename: Name of the uploaded file. If this parameter is not set and multipart body is used, the file name from the multipart body will be used (this parameter takes precedence). If raw request body is used this parameter is required.
        :param bool info: Return full file info (`FilesFile`) in the response.
        :param bool overwrite: Overwrite an existing file.
        :param float overwrite_if_modified: Overwrite an existing file if modified matches.
        :param float overwrite_if_size: Overwrite an existing file if size matches.
        :param str overwrite_if_hash: Overwrite an existing file if hash matches.
        :param bool overwrite_ignore_nonexistent: Overwrite an existing file if other parameters match (e.g. overWriteIfModified) but create a new file if the old one does not exist.
        :param bool autorename: Overwrite an existing file.
        :param float modified: Set custom value for modified. Current time by default.
        :param list[str] tags: Tags for the new file. Format: key=value
        :return: FilesFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'body', 'filename', 'info', 'overwrite', 'overwrite_if_modified', 'overwrite_if_size', 'overwrite_if_hash', 'overwrite_ignore_nonexistent', 'autorename', 'modified', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_content_files_put`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_content_files_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'overwrite' in params:
            query_params.append(('overwrite', params['overwrite']))  # noqa: E501
        if 'overwrite_if_modified' in params:
            query_params.append(('overwriteIfModified', params['overwrite_if_modified']))  # noqa: E501
        if 'overwrite_if_size' in params:
            query_params.append(('overwriteIfSize', params['overwrite_if_size']))  # noqa: E501
        if 'overwrite_if_hash' in params:
            query_params.append(('overwriteIfHash', params['overwrite_if_hash']))  # noqa: E501
        if 'overwrite_ignore_nonexistent' in params:
            query_params.append(('overwriteIgnoreNonexistent', params['overwrite_ignore_nonexistent']))  # noqa: E501
        if 'autorename' in params:
            query_params.append(('autorename', params['autorename']))  # noqa: E501
        if 'modified' in params:
            query_params.append(('modified', params['modified']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/mounts/{mountId}/files/put', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_content_files_put(self, path, mount_id, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        File can be uploaded either using a multi-part form or directly. You can use Chunked transfer encoding if the size of the file is not known in advance (streaming upload).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_put(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param str file:
        :param str filename: Name of the uploaded file. If this parameter is not set and multipart body is used, the file name from the multipart body will be used (this parameter takes precedence). If raw request body is used this parameter is required.
        :param bool info: Return full file info (`FilesFile`) in the response.
        :param bool overwrite: Overwrite an existing file.
        :param float overwrite_if_modified: Overwrite an existing file if modified matches.
        :param float overwrite_if_size: Overwrite an existing file if size matches.
        :param str overwrite_if_hash: Overwrite an existing file if hash matches.
        :param bool overwrite_ignore_nonexistent: Overwrite an existing file if other parameters match (e.g. overWriteIfModified) but create a new file if the old one does not exist.
        :param bool autorename: Overwrite an existing file.
        :param float modified: Set custom value for modified. Current time by default.
        :param list[str] tags: Tags for the new file. Format: key=value
        :return: FilesFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_content_files_put_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_content_files_put_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_content_files_put_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        File can be uploaded either using a multi-part form or directly. You can use Chunked transfer encoding if the size of the file is not known in advance (streaming upload).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_content_files_put_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param str file:
        :param str filename: Name of the uploaded file. If this parameter is not set and multipart body is used, the file name from the multipart body will be used (this parameter takes precedence). If raw request body is used this parameter is required.
        :param bool info: Return full file info (`FilesFile`) in the response.
        :param bool overwrite: Overwrite an existing file.
        :param float overwrite_if_modified: Overwrite an existing file if modified matches.
        :param float overwrite_if_size: Overwrite an existing file if size matches.
        :param str overwrite_if_hash: Overwrite an existing file if hash matches.
        :param bool overwrite_ignore_nonexistent: Overwrite an existing file if other parameters match (e.g. overWriteIfModified) but create a new file if the old one does not exist.
        :param bool autorename: Overwrite an existing file.
        :param float modified: Set custom value for modified. Current time by default.
        :param list[str] tags: Tags for the new file. Format: key=value
        :return: FilesFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'file', 'filename', 'info', 'overwrite', 'overwrite_if_modified', 'overwrite_if_size', 'overwrite_if_hash', 'overwrite_ignore_nonexistent', 'autorename', 'modified', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_content_files_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_content_files_put`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_content_files_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'overwrite' in params:
            query_params.append(('overwrite', params['overwrite']))  # noqa: E501
        if 'overwrite_if_modified' in params:
            query_params.append(('overwriteIfModified', params['overwrite_if_modified']))  # noqa: E501
        if 'overwrite_if_size' in params:
            query_params.append(('overwriteIfSize', params['overwrite_if_size']))  # noqa: E501
        if 'overwrite_if_hash' in params:
            query_params.append(('overwriteIfHash', params['overwrite_if_hash']))  # noqa: E501
        if 'overwrite_ignore_nonexistent' in params:
            query_params.append(('overwriteIgnoreNonexistent', params['overwrite_ignore_nonexistent']))  # noqa: E501
        if 'autorename' in params:
            query_params.append(('autorename', params['autorename']))  # noqa: E501
        if 'modified' in params:
            query_params.append(('modified', params['modified']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content/api/v2.1/mounts/{mountId}/files/put', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_copy(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_copy(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesCopy body: TODO
        :return: FilesCopyResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_copy_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_copy_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_copy_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_copy_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesCopy body: TODO
        :return: FilesCopyResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_copy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_copy`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_copy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/copy', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesCopyResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_create(self, mount_id, path, template, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_create(mount_id, path, template, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param str template: (required)
        :return: FilesCreateResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_create_with_http_info(mount_id, path, template, **kwargs)  # noqa: E501
        else:
            (data) = self.files_create_with_http_info(mount_id, path, template, **kwargs)  # noqa: E501
            return data

    def files_create_with_http_info(self, mount_id, path, template, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_create_with_http_info(mount_id, path, template, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param str template: (required)
        :return: FilesCreateResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path', 'template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_create`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_create`")  # noqa: E501
        # verify the required parameter 'template' is set
        if ('template' not in params or
                params['template'] is None):
            raise ValueError("Missing the required parameter `template` when calling `files_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501
        if 'template' in params:
            path_params['template'] = params['template']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/create/{template}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesCreateResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_external(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_external(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_external_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_external_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_external_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_external_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_external" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_external`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_external`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/external', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_external_status(self, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_external_status(mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :return: FilesExternalStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_external_status_with_http_info(mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_external_status_with_http_info(mount_id, **kwargs)  # noqa: E501
            return data

    def files_external_status_with_http_info(self, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_external_status_with_http_info(mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :return: FilesExternalStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_external_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_external_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/externalstatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesExternalStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_folder_new(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_folder_new(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesFolderCreate body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_folder_new_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_folder_new_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_folder_new_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_folder_new_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesFolderCreate body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_folder_new" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_folder_new`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_folder_new`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/folder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_get(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_get(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_get_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_get_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_get_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_get_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_get`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/get', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_get_link(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_get_link(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesGetLink
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_get_link_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_get_link_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_get_link_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_get_link_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesGetLink
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_get_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_get_link`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_get_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesGetLink',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_info_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_info_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_info_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_info_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_info`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_list(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_list(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: Files
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_list_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_list_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_list_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_list_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: Files
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_list`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Files',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_move(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_move(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesMove body: TODO
        :return: FilesMoveResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_move_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_move_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_move_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_move_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesMove body: TODO
        :return: FilesMoveResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_move" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_move`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_move`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/move', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesMoveResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_remove(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_remove(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesRemove
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_remove_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_remove_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_remove_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_remove_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesRemove
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_remove" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_remove`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_remove`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/remove', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesRemove',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_rename(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_rename(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesRename body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_rename_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_rename_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_rename_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_rename_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesRename body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_rename" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_rename`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_rename`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/rename', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_tags_add(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_tags_add(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesTagsAdd body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_tags_add_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_tags_add_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_tags_add_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_tags_add_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesTagsAdd body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_tags_add" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_tags_add`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_tags_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/tags/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_tags_remove(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_tags_remove(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesTagsRemove body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_tags_remove_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_tags_remove_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_tags_remove_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_tags_remove_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesTagsRemove body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_tags_remove" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_tags_remove`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_tags_remove`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/tags/remove', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_tags_set(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_tags_set(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesTagsSet body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_tags_set_with_http_info(path, mount_id, **kwargs)  # noqa: E501
        else:
            (data) = self.files_tags_set_with_http_info(path, mount_id, **kwargs)  # noqa: E501
            return data

    def files_tags_set_with_http_info(self, path, mount_id, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_tags_set_with_http_info(path, mount_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param str mount_id: (required)
        :param FilesTagsSet body: TODO
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'mount_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_tags_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_tags_set`")  # noqa: E501
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_tags_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/tags/set', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_upload(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_upload(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesUploadLink
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_upload_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_upload_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_upload_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_upload_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesUploadLink
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_upload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_upload`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/upload', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesUploadLink',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_versions(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_versions(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_versions_with_http_info(mount_id, path, **kwargs)  # noqa: E501
        else:
            (data) = self.files_versions_with_http_info(mount_id, path, **kwargs)  # noqa: E501
            return data

    def files_versions_with_http_info(self, mount_id, path, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_versions_with_http_info(mount_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :return: FilesVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_versions`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesVersions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def files_versions_recover(self, mount_id, path, version, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_versions_recover(mount_id, path, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param str version: (required)
        :return: FilesVersionsRecover
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.files_versions_recover_with_http_info(mount_id, path, version, **kwargs)  # noqa: E501
        else:
            (data) = self.files_versions_recover_with_http_info(mount_id, path, version, **kwargs)  # noqa: E501
            return data

    def files_versions_recover_with_http_info(self, mount_id, path, version, **kwargs):  # noqa: E501
        """TODO  # noqa: E501

        TODO  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.files_versions_recover_with_http_info(mount_id, path, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mount_id: (required)
        :param str path: (required)
        :param str version: (required)
        :return: FilesVersionsRecover
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mount_id', 'path', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method files_versions_recover" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mount_id' is set
        if ('mount_id' not in params or
                params['mount_id'] is None):
            raise ValueError("Missing the required parameter `mount_id` when calling `files_versions_recover`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `files_versions_recover`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `files_versions_recover`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mount_id' in params:
            path_params['mountId'] = params['mount_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['appPassword', 'bearer', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2.1/mounts/{mountId}/files/versions/recover', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesVersionsRecover',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
